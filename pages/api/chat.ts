import { NextApiRequest, NextApiResponse } from 'next';
import OpenAI from 'openai';

// Initialize OpenAI client with fallback error handling
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY || 'sk-placeholder-for-build',
});

type ChatMessage = {
  role: 'system' | 'user' | 'assistant';
  content: string;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  // Check if API key is configured
  if (!process.env.OPENAI_API_KEY || 
      process.env.OPENAI_API_KEY === 'your-openai-api-key-here' ||
      process.env.OPENAI_API_KEY === 'sk-placeholder-for-build') {
    return res.status(401).json({ 
      error: 'OpenAI API key is not configured. This is expected in the demo environment. In a production environment, you would need to set a valid API key.'
    });
  }

  // Use a placeholder assistant ID if not configured
  const assistantId = process.env.OPENAI_ASSISTANT_ID || 'asst-placeholder-for-build';

  try {
    const { message, history = [], threadId: existingThreadId } = req.body;

    if (!message) {
      return res.status(400).json({ error: 'Message is required' });
    }

    let threadId = existingThreadId;
    
    // Create a new thread if one doesn't exist
    if (!threadId) {
      const thread = await openai.beta.threads.create();
      threadId = thread.id;
    }
    
    // Add the message to the thread
    await openai.beta.threads.messages.create(
      threadId,
      {
        role: "user",
        content: message
      }
    );
    
    // Run the assistant
    const run = await openai.beta.threads.runs.create(
      threadId,
      {
        assistant_id: assistantId,
      }
    );
    
    // Poll for completion
    let runStatus = await openai.beta.threads.runs.retrieve(
      threadId,
      run.id
    );
    
    // Wait for the run to complete
    while (runStatus.status === "queued" || runStatus.status === "in_progress") {
      // Wait for 500ms before checking again
      await new Promise(resolve => setTimeout(resolve, 500));
      runStatus = await openai.beta.threads.runs.retrieve(
        threadId,
        run.id
      );
    }
    
    if (runStatus.status !== "completed") {
      console.error("Run failed with status:", runStatus.status);
      return res.status(500).json({ 
        error: `Assistant run failed with status: ${runStatus.status}` 
      });
    }
    
    // Retrieve messages after completion
    const messages = await openai.beta.threads.messages.list(
      threadId
    );
    
    // Get the last assistant message
    const lastMessage = messages.data
      .filter(msg => msg.role === "assistant")
      .sort((a, b) => 
        new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
      )[0];
    
    if (!lastMessage) {
      return res.status(500).json({ 
        error: "No response generated by assistant" 
      });
    }
    
    // Extract text content from the message
    let reply = "";
    if (lastMessage.content[0].type === "text") {
      reply = lastMessage.content[0].text.value;
    }
    
    return res.status(200).json({ 
      content: reply,
      threadId: threadId // Return thread ID for future messages
    });
  } catch (error) {
    console.error('Chat API error:', error);
    
    if (error instanceof OpenAI.APIError) {
      // Provide a more user-friendly message for API key errors
      if (error.code === 'invalid_api_key') {
        return res.status(401).json({ 
          error: 'OpenAI API key is invalid. Please check your API key in your .env.local file.' 
        });
      }
      
      return res.status(error.status || 500).json({ 
        error: `OpenAI API error: ${error.message}` 
      });
    }
    
    return res.status(500).json({ 
      error: 'An unexpected error occurred while processing your request'
    });
  }
} 